/*
    Rust 将错误分为两大类：可恢复的（recoverable）和 不可恢复的（unrecoverable）错误。
    对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。
    不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。

    大多数语言并不区分这两种错误，并采用类似异常这样方式统一处理他们。
    Rust 没有异常。
    相反，它有 Result<T, E> 类型，用于处理可恢复的错误，还有 panic! 宏，在程序遇到不可恢复的错误时停止执行。
*/

/*
在实践中有两种方法造成 panic：执行会造成代码 panic 的操作（比如访问超过数组结尾的内容）或者显式调用 panic! 宏。
这两种情况都会使程序 panic。通常情况下这些 panic 会打印出一个错误信息，展开并清理栈数据，然后退出。
通过一个环境变量，你也可以让 Rust 在 panic 发生时打印调用堆栈（call stack）以便于定位 panic 的原因。

当出现 panic 时，程序默认会开始 展开（unwinding），
这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。
另一种选择是直接 终止（abort），这会不清理数据就退出程序。

那么程序所使用的内存需要由操作系统来清理。
如果你需要项目的最终二进制文件越小越好，panic 时通过在 Cargo.toml 的 [profile] 部分增加 panic = 'abort'，可以由展开切换为终止。
*/

fn test_func1() {
    let v = vec![1, 2, 3];

    v[99];
}

fn main() {
    test_func1();
}
